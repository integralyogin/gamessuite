// js/bitDefenderGame.js
// Generated by the WorldEngine, extended for tower defense gameplay.
// Modified to include game speed controls, enemy camps, and player-built camps.

const bitDefenderGame = {
    id: 'bitDefenderGame',
    container: null,
    successCallback: null,
    failureCallback: null,
    sharedData: null,

    // Game state properties
    canvas: null,
    ctx: null,
    gameLoopId: null,
    playerUnits: [],
    playerTowers: [], 
    playerCamps: [], // NEW: Player-built camps
    enemyUnits: [],
    enemyCamps: [], 
    projectiles: [],
    effects: [], 
    coins: 120, 
    baseHealth: 100,

    // Mouse and UI state
    isDragging: false,
    mousePos: { x: 0, y: 0 },
    buildMode: null, 
    selectedTower: null, 

    // Game Speed Control
    gameSpeed: 1, // Current speed multiplier

    // Game constants
    WALL_WIDTH: 280,
    MOAT_WIDTH: 30,
    BRIDGE_Y: 0,
    BRIDGE_HEIGHT: 50,
    SEPARATION_RADIUS: 8,
    
    // Wave management and Enemy AI
    waveNumber: 0,
    waveTimer: 450, 
    campSpawnTimer: 1200, 
    spawnTimer: 0,
    enemiesToSpawn: 0,
    stagingAreas: [], 
    pathingLanes: [], 
    attackThreshold: 1,

    init: function(container, successCallback, failureCallback, sharedData) {
        this.container = container;
        this.successCallback = successCallback;
        this.failureCallback = failureCallback;
        this.sharedData = sharedData;

        console.log(`bitDefenderGame: Initializing.`);
        this.render();
        this.startGame();
    },

    render: function() {
        this.container.innerHTML = `
            <div style="position: relative; width: 100%; height: 100%; display: flex; justify-content: center; align-items: center; background-color: #333; font-family: monospace;">
                <div style="position: relative; width: 800px; height: 400px;">
                    <canvas id="gameCanvas" style="background-color: #6B8E23; border: 1px solid #ccc; width: 100%; height: 100%; cursor: default;"></canvas>
                    <div style="position: absolute; top: 10px; left: 10px; color: #fff; text-shadow: 1px 1px #000;">
                        <div><strong>Health:</strong> <span id="health-stat"></span></div>
                        <div><strong>Coins:</strong> <span id="coins-stat"></span></div>
                        <div><strong>Wave:</strong> <span id="wave-stat"></span></div>
                    </div>
                    <div id="controls-panel" style="position: absolute; top: 10px; right: 10px; display:flex; flex-direction: column; gap: 5px; align-items: flex-end;">
                        <!-- Build Buttons -->
                        <div style="display:flex; flex-wrap: wrap; gap: 5px; justify-content: flex-end;">
                            <button id="build-arrow-tower-btn" title="Basic single target tower" style="padding: 5px; font-size: 11px; cursor: pointer; background-color: #cda; border: 1px solid #888;">Arrow Tower (15c)</button>
                            <button id="build-cannon-tower-btn" title="Area of effect damage" style="padding: 5px; font-size: 11px; cursor: pointer; background-color: #f99; border: 1px solid #888;">Cannon Tower (25c)</button>
                            <button id="build-slow-tower-btn" title="Slows enemies in a radius" style="padding: 5px; font-size: 11px; cursor: pointer; background-color: #aaf; border: 1px solid #888;">Slow Tower (20c)</button>
                            <button id="build-camp-btn" title="Build a camp to spawn units" style="padding: 5px; font-size: 11px; cursor: pointer; background-color: #dcb; border: 1px solid #888;">Build Camp (30c)</button>
                        </div>
                        <!-- Unit and Exit Buttons -->
                        <div style="display:flex; gap: 5px; margin-top: 5px;">
                            <button id="add-melee-btn" style="padding: 5px; font-size: 11px; cursor: pointer; background-color: #ddd; border: 1px solid #888;">Melee (5c)</button>
                            <button id="bitDefenderGame-exit-btn" style="padding: 5px 10px; font-size: 12px; cursor: pointer; background-color: #fdd; border: 1px solid #800;">Exit</button>
                        </div>
                        <!-- Speed Controls -->
                        <div id="speed-controls" style="display:flex; gap: 4px; align-items: center; margin-top: 5px; padding: 4px; background-color: rgba(0,0,0,0.2); border-radius: 5px;">
                             <span style="color: #fff; font-size: 11px; margin-right: 4px;">Speed:</span>
                             <button id="speed-1x-btn" class="speed-btn" style="padding: 3px 8px; font-size: 11px; cursor: pointer; border: 1px solid #fff; background-color: #888; color: #fff; border-radius: 3px;">1x</button>
                             <button id="speed-2x-btn" class="speed-btn" style="padding: 3px 8px; font-size: 11px; cursor: pointer; border: 1px solid #888; background-color: #ccc; border-radius: 3px;">2x</button>
                             <button id="speed-5x-btn" class="speed-btn" style="padding: 3px 8px; font-size: 11px; cursor: pointer; border: 1px solid #888; background-color: #ccc; border-radius: 3px;">5x</button>
                             <button id="speed-10x-btn" class="speed-btn" style="padding: 3px 8px; font-size: 11px; cursor: pointer; border: 1px solid #888; background-color: #ccc; border-radius: 3px;">10x</button>
                        </div>
                    </div>
                </div>
            </div>
        `;

        // --- Event Listeners ---
        document.getElementById(`bitDefenderGame-exit-btn`).onclick = () => this.successCallback({ message: `Returned from bitDefenderGame` });
        document.getElementById('add-melee-btn').onclick = () => this.addUnit('melee');
        document.getElementById('build-arrow-tower-btn').onclick = () => this.enterBuildMode('arrow');
        document.getElementById('build-cannon-tower-btn').onclick = () => this.enterBuildMode('cannon');
        document.getElementById('build-slow-tower-btn').onclick = () => this.enterBuildMode('slow');
        document.getElementById('build-camp-btn').onclick = () => this.enterBuildMode('playerCamp'); // NEW

        // Speed control listeners
        document.getElementById('speed-1x-btn').onclick = () => this.setGameSpeed(1);
        document.getElementById('speed-2x-btn').onclick = () => this.setGameSpeed(2);
        document.getElementById('speed-5x-btn').onclick = () => this.setGameSpeed(5);
        document.getElementById('speed-10x-btn').onclick = () => this.setGameSpeed(10);
    },
    
    startGame: function() {
        this.canvas = document.getElementById('gameCanvas');
        this.ctx = this.canvas.getContext('2d');
        this.canvas.width = 800;
        this.canvas.height = 400;

        this.BRIDGE_Y = this.canvas.height / 2 - this.BRIDGE_HEIGHT / 2;
        this.stagingAreas = [
            { x: this.canvas.width - 60, y: this.canvas.height * 0.25 },
            { x: this.canvas.width - 60, y: this.canvas.height * 0.75 }
        ];

        const bridgeLaneOffset = this.BRIDGE_HEIGHT / 4;
        this.pathingLanes = [
            { x: this.WALL_WIDTH + this.MOAT_WIDTH, y: this.BRIDGE_Y + bridgeLaneOffset },
            { x: this.WALL_WIDTH + this.MOAT_WIDTH, y: this.BRIDGE_Y + this.BRIDGE_HEIGHT / 2 },
            { x: this.WALL_WIDTH + this.MOAT_WIDTH, y: this.BRIDGE_Y + this.BRIDGE_HEIGHT - bridgeLaneOffset }
        ];

        this.canvas.addEventListener('mousedown', this.handleMouseDown.bind(this));
        this.canvas.addEventListener('mousemove', this.handleMouseMove.bind(this));
        this.canvas.addEventListener('mouseup', this.handleMouseUp.bind(this));
        this.canvas.addEventListener('mouseleave', this.handleMouseUp.bind(this));

        this.gameLoopId = requestAnimationFrame(this.gameLoop.bind(this));
    },

    // --- Input and UI Handlers ---
    getMousePos: function(event) {
        const rect = this.canvas.getBoundingClientRect();
        return { x: event.clientX - rect.left, y: event.clientY - rect.top };
    },

    handleMouseDown: function(event) {
        const pos = this.getMousePos(event);
        if (this.buildMode) { 
            if (this.buildMode === 'playerCamp') {
                this.placePlayerCamp(pos);
            } else {
                this.placeTower(pos); 
            }
            return; 
        }
        
        let clickedOnUI = false;
        if(this.selectedTower && this.selectedTower.upgradeButtonRect){
            const btn = this.selectedTower.upgradeButtonRect;
            if(pos.x > btn.x && pos.x < btn.x + btn.w && pos.y > btn.y && pos.y < btn.y + btn.h){
                this.upgradeTower(this.selectedTower);
                clickedOnUI = true;
            }
        }
        
        this.selectedTower = null;
        if (clickedOnUI) return;

        for(const tower of this.playerTowers) {
            const dist = Math.sqrt(Math.pow(pos.x - tower.x, 2) + Math.pow(pos.y - tower.y, 2));
            if(dist < 10) { this.selectedTower = tower; return; }
        }

        this.isDragging = true;
        this.mousePos = pos;
    },

    handleMouseMove: function(event) {
        this.mousePos = this.getMousePos(event);
        if (this.isDragging) { /* drag logic here */ }
        this.canvas.style.cursor = this.buildMode ? 'crosshair' : 'default';
    },

    handleMouseUp: function() { this.isDragging = false; },

    setGameSpeed: function(speed) {
        this.gameSpeed = speed;

        const buttons = this.container.querySelectorAll('.speed-btn');
        buttons.forEach(btn => {
            const btnSpeed = parseInt(btn.id.match(/(\d+)x/)[1], 10);
            btn.style.backgroundColor = (btnSpeed === speed) ? '#888' : '#ccc';
            btn.style.color = (btnSpeed === speed) ? '#fff' : '#000';
            btn.style.border = (btnSpeed === speed) ? '1px solid #fff' : '1px solid #888';
        });
    },

    // --- Structure Management ---
    enterBuildMode: function(structureType) {
        const costs = { 'arrow': 15, 'cannon': 25, 'slow': 20, 'playerCamp': 30 };
        if (this.coins >= costs[structureType]) { 
            this.buildMode = structureType; 
            this.selectedTower = null; 
        }
    },

    placeTower: function(pos) {
        if (!this.buildMode || pos.x > this.WALL_WIDTH - 8 || pos.x < 8) { this.buildMode = null; return; }
        const costs = { 'arrow': 15, 'cannon': 25, 'slow': 20 };
        if (this.coins >= costs[this.buildMode]) {
            this.coins -= costs[this.buildMode];
            let newTower = { x: pos.x, y: pos.y, type: this.buildMode, level: 1, cooldown: 0, };
            if(this.buildMode === 'arrow') { Object.assign(newTower, { health: 75, maxHealth: 75, damage: 5, range: 150, attackSpeed: 75 }); } 
            else if (this.buildMode === 'cannon') { Object.assign(newTower, { health: 125, maxHealth: 125, damage: 8, range: 130, splashRadius: 30, attackSpeed: 150 }); } 
            else if (this.buildMode === 'slow') { Object.assign(newTower, { health: 100, maxHealth: 100, slowFactor: 0.5, range: 100 }); }
            this.playerTowers.push(newTower);
        }
        this.buildMode = null;
    },
    
    placePlayerCamp: function(pos) {
        if (!this.buildMode === 'playerCamp' || pos.x > this.WALL_WIDTH - 15) { this.buildMode = null; return; }
        const cost = 30;
        if (this.coins >= cost) {
            this.coins -= cost;
            this.playerCamps.push({
                x: pos.x, y: pos.y,
                health: 100, maxHealth: 100,
                spawnTimer: 400, // Initial delay before first spawn
                spawnCooldown: 400, // Time between spawns
                type: 'playerCamp'
            });
        }
        this.buildMode = null;
    },

    upgradeTower: function(tower){
        const cost = 10 * Math.pow(2, tower.level);
        if(this.coins >= cost){
            this.coins -= cost; tower.level++; tower.range += 10;
            tower.health = tower.maxHealth; 
            if(tower.type === 'arrow'){ tower.damage += 3; }
            if(tower.type === 'cannon'){ tower.damage += 5; tower.splashRadius += 5;}
            if(tower.type === 'slow'){ tower.slowFactor = Math.max(0.2, tower.slowFactor - 0.05); }
        }
    },
    
    updateTowers: function() {
        for(let i = this.playerTowers.length - 1; i >= 0; i--){
            const tower = this.playerTowers[i];
            if (tower.health <= 0) {
                this.effects.push({ x: tower.x, y: tower.y, radius: 20, maxRadius: 20, duration: 20, maxDuration: 20, color: 'rgba(150, 150, 150, 0.6)' });
                this.playerTowers.splice(i, 1);
                if (this.selectedTower === tower) this.selectedTower = null;
                continue;
            }
            
            if(tower.type === 'slow') continue;
            
            tower.cooldown = Math.max(0, tower.cooldown - 1);
            if(tower.cooldown === 0){
                let target = null;
                let minDistance = tower.range;
                const potentialTargets = [...this.enemyUnits, ...this.enemyCamps];

                for (const potentialTarget of potentialTargets) {
                    if (potentialTarget.type === 'flyer' && tower.type === 'cannon') continue;
                    const distance = Math.sqrt(Math.pow(potentialTarget.x - tower.x, 2) + Math.pow(potentialTarget.y - tower.y, 2));
                    if(distance < minDistance){ minDistance = distance; target = potentialTarget; }
                }

                if(target){
                    this.projectiles.push({ x: tower.x, y: tower.y, target: target, speed: 4, damage: tower.damage, type: tower.type, splashRadius: tower.splashRadius });
                    tower.cooldown = tower.attackSpeed;
                }
            }
        }
    },
    
    updatePlayerCamps: function() {
        for(let i = this.playerCamps.length - 1; i >= 0; i--) {
            const camp = this.playerCamps[i];
            
            if (camp.health <= 0) {
                this.effects.push({ x: camp.x, y: camp.y, radius: 25, maxRadius: 25, duration: 25, maxDuration: 25, color: 'rgba(150, 150, 150, 0.6)' });
                this.playerCamps.splice(i, 1);
                continue;
            }
            
            camp.spawnTimer--;
            if (camp.spawnTimer <= 0) {
                camp.spawnTimer = camp.spawnCooldown;
                this.addUnit('melee', camp.x, camp.y);
            }
        }
    },

    updateSlowEffects: function() {
        for(const enemy of this.enemyUnits) { enemy.currentSpeed = enemy.baseSpeed; }
        for(const tower of this.playerTowers) {
            if(tower.type === 'slow') {
                for (const enemy of this.enemyUnits) {
                    const distance = Math.sqrt(Math.pow(enemy.x - tower.x, 2) + Math.pow(enemy.y - tower.y, 2));
                    if(distance < tower.range){ enemy.currentSpeed *= tower.slowFactor; }
                }
            }
        }
    },

    // --- Main Game Loop ---
    gameLoop: function() {
        for (let i = 0; i < this.gameSpeed; i++) {
            if (this.baseHealth > 0) this.update();
            else break;
        }
        this.draw();
        if (this.baseHealth > 0) this.gameLoopId = requestAnimationFrame(this.gameLoop.bind(this));
        else this.gameOver();
    },

    update: function() {
        this.updateWaveSystem();
        this.updateEnemyCamps();
        this.updatePlayerCamps(); 
        this.updateSlowEffects();
        this.updateEnemies();
        this.updatePlayerUnits();
        this.updateTowers();
        this.updateProjectiles();
        this.updateEffects();
        this.applySeparation(this.playerUnits);
        this.applySeparation(this.enemyUnits);
    },
    
    updateWaveSystem: function(){
        if (this.enemiesToSpawn === 0 && this.enemyUnits.length === 0) {
            this.waveTimer--;
            if (this.waveTimer <= 0) {
                this.waveNumber++; this.enemiesToSpawn = 8 + this.waveNumber * 10;
                this.attackThreshold = 1; this.waveTimer = 450;
            }
        }
        
        this.spawnTimer--;
        if (this.enemiesToSpawn > 0 && this.spawnTimer <= 0) {
            this.spawnEnemy(); this.enemiesToSpawn--; this.spawnTimer = 25; 
        }

        if(this.waveNumber > 1) { 
            this.campSpawnTimer--;
            if(this.campSpawnTimer <= 0) {
                this.spawnEnemyCamp();
                this.campSpawnTimer = 1500 - (this.waveNumber * 50); 
            }
        }
        
        for (const area of this.stagingAreas) {
            const stagedEnemies = this.enemyUnits.filter(e => e.state === 'staged' && e.stagingTarget === area);
            if (stagedEnemies.length >= this.attackThreshold) { this.launchStagedAttack(area); }
        }
        if (this.enemiesToSpawn === 0 && this.enemyUnits.some(e => e.state === 'staged')) {
            for(const enemy of this.enemyUnits) { if(enemy.state === 'staged') enemy.state = 'attacking'; }
        }
    },

    spawnEnemyCamp: function() { // BUG FIX: Added missing function
        const campX = this.canvas.width - Math.random() * 150 - 20;
        const campY = Math.random() * (this.canvas.height - 40) + 20;
        
        this.enemyCamps.push({
            x: campX, y: campY,
            health: 80, maxHealth: 80,
            spawnTimer: 0,
            spawnCooldown: 350,
            type: 'camp'
        });
    },

    updateEnemyCamps: function() {
        for(let i = this.enemyCamps.length - 1; i >= 0; i--) {
            const camp = this.enemyCamps[i];
            if (camp.health <= 0) {
                this.effects.push({ x: camp.x, y: camp.y, radius: 25, maxRadius: 25, duration: 25, maxDuration: 25, color: 'rgba(139, 69, 19, 0.7)' });
                this.coins += 25; 
                this.enemyCamps.splice(i, 1);
                continue;
            }
            
            camp.spawnTimer--;
            if (camp.spawnTimer <= 0) {
                camp.spawnTimer = camp.spawnCooldown;
                const enemyData = { health: 10, speed: 0.5 + Math.random() * 0.5 };
                let enemy = {
                    x: camp.x, y: camp.y,
                    health: enemyData.health, maxHealth: enemyData.health,
                    baseSpeed: enemyData.speed, currentSpeed: enemyData.speed,
                    type: 'melee', state: 'attacking', attackCooldown: 0,
                    pathingLane: this.pathingLanes[Math.floor(Math.random() * this.pathingLanes.length)]
                };
                this.enemyUnits.push(enemy);
            }
        }
    },
    
    spawnEnemy: function() {
        let enemyType = 'melee'; const random = Math.random();
        if (this.waveNumber > 4 && random < 0.15) { enemyType = 'flyer'; }
        else if (this.waveNumber > 3 && random < 0.35) { enemyType = 'speedy'; }
        else if (this.waveNumber > 2 && random < 0.60) { enemyType = 'tank'; }

        const stats = {
            melee: { health: 10, speed: 0.5 + Math.random() * 0.5 },
            tank: { health: 50, speed: 0.3 },
            speedy: { health: 8, speed: 1.5 },
            flyer: { health: 12, speed: 0.7 }
        };
        const enemyData = stats[enemyType];

        let enemy = {
            x: this.canvas.width - 5, y: Math.random() * this.canvas.height,
            health: enemyData.health, maxHealth: enemyData.health,
            baseSpeed: enemyData.speed, currentSpeed: enemyData.speed,
            type: enemyType, state: 'attacking', attackCooldown: 0,
        };
        
        if (enemyType !== 'flyer') {
            const platoonIndex = this.enemyUnits.filter(e => e.type !== 'flyer').length % 2;
            enemy.stagingTarget = this.stagingAreas[platoonIndex];
            enemy.pathingLane = this.pathingLanes[Math.floor(Math.random() * this.pathingLanes.length)];
            enemy.state = 'gathering';
        }
        this.enemyUnits.push(enemy);
    },

    launchStagedAttack: function(stagingTarget) { 
        for (const enemy of this.enemyUnits) {
            if (enemy.stagingTarget === stagingTarget && (enemy.state === 'staged' || enemy.state === 'gathering')) {
                enemy.state = 'attacking';
            }
        }
    },
    
    updateEnemies: function() { 
        const bridgeEntranceX = this.WALL_WIDTH + this.MOAT_WIDTH + 5;
        for (let i = this.enemyUnits.length - 1; i >= 0; i--) {
            const enemy = this.enemyUnits[i]; let isEngaged = false;

            if(enemy.type === 'flyer'){
                enemy.x -= enemy.currentSpeed;
            } else {
                switch(enemy.state) {
                    case 'gathering':
                        const gdx = enemy.stagingTarget.x - enemy.x; const gdy = enemy.stagingTarget.y - enemy.y;
                        const gdist = Math.sqrt(gdx*gdx + gdy*gdy);
                        if (gdist > enemy.currentSpeed) { enemy.x += (gdx/gdist) * enemy.currentSpeed; enemy.y += (gdy/gdist) * enemy.currentSpeed; } else { enemy.state = 'staged'; }
                        break;
                    case 'staged': break;
                    case 'attacking':
                        let target = null; let minTargetDist = 20;
                        const potentialTargets = [...this.playerTowers, ...this.playerCamps];
                        for (const pTarget of potentialTargets) {
                            const dist = Math.sqrt(Math.pow(pTarget.x - enemy.x, 2) + Math.pow(pTarget.y - enemy.y, 2));
                            if (dist < minTargetDist) { minTargetDist = dist; target = pTarget; }
                        }

                        if(target) { 
                            isEngaged = true; 
                            enemy.attackCooldown = (enemy.attackCooldown || 0) - 1; 
                            if(enemy.attackCooldown <= 0) { 
                                target.health -= 1; 
                                enemy.attackCooldown = 60; 
                            } 
                        }

                        if(!isEngaged) {
                            let targetUnit = null; let minUnitDist = 15;
                            for (const playerUnit of this.playerUnits) {
                                const dist = Math.sqrt(Math.pow(playerUnit.x - enemy.x, 2) + Math.pow(playerUnit.y - enemy.y, 2));
                                if (dist < minUnitDist) { minUnitDist = dist; targetUnit = playerUnit; }
                            }
                            if(targetUnit){ isEngaged = true; enemy.attackCooldown = (enemy.attackCooldown || 0) - 1; if (enemy.attackCooldown <= 0) { targetUnit.health -= 2; enemy.attackCooldown = 60; } }
                        }
                        if (!isEngaged) {
                            const targetY = enemy.pathingLane.y;
                            if (enemy.x > bridgeEntranceX) {
                                enemy.x -= enemy.currentSpeed;
                                if (Math.abs(enemy.y - targetY) > enemy.currentSpeed) { enemy.y += Math.sign(targetY - enemy.y) * enemy.currentSpeed; }
                            } else { enemy.x -= enemy.currentSpeed; }
                        }
                        break;
                }
            }
            if (enemy.x <= 0) { this.baseHealth -= 10; this.enemyUnits.splice(i, 1); }
        }
    },
    
    updatePlayerUnits: function() { 
        const bridgeCenter = { x: this.WALL_WIDTH + this.MOAT_WIDTH / 2, y: this.canvas.height / 2 };
        for (let i = this.playerUnits.length - 1; i >= 0; i--) {
            const unit = this.playerUnits[i];
            if(unit.health <= 0){ this.playerUnits.splice(i, 1); continue; }
            let isEngaged = false; let targetPos = null;
            if (unit.type === 'melee') {
                let target = null; let minDistance = 15;
                const potentialTargets = [...this.enemyUnits, ...this.enemyCamps];
                for (const potentialTarget of potentialTargets) {
                    if (potentialTarget.type === 'flyer') continue;
                    const distance = Math.sqrt(Math.pow(potentialTarget.x - unit.x, 2) + Math.pow(potentialTarget.y - unit.y, 2));
                    if(distance < minDistance){ minDistance = distance; target = potentialTarget; }
                }

                if(target){
                    isEngaged = true; unit.attackCooldown = (unit.attackCooldown || 0) - 1;
                    if(unit.attackCooldown <= 0){
                        target.health -= 4;
                        if (target.health <= 0) {
                            this.coins += (target.type === 'camp' ? 10 : 2); 
                            const enemyIndex = this.enemyUnits.indexOf(target);
                            if(enemyIndex > -1) this.enemyUnits.splice(enemyIndex, 1);
                        }
                        unit.attackCooldown = 60;
                    }
                }
            }
            if(!isEngaged) {
                if (this.isDragging) { unit.manualTarget = this.mousePos; }
                if (unit.manualTarget) { targetPos = unit.manualTarget; }
                else if (unit.type === 'melee' && (this.enemyUnits.length > 0 || this.enemyCamps.length > 0)) {
                    let closestTarget = null; let minDistance = unit.detectionRange;
                    const potentialTargets = [...this.enemyUnits.filter(e => e.type !== 'flyer'), ...this.enemyCamps];
                    for (const target of potentialTargets) {
                        const distance = Math.sqrt(Math.pow(target.x - unit.x, 2) + Math.pow(target.y - unit.y, 2));
                        if (distance < minDistance) { minDistance = distance; closestTarget = target; }
                    }
                    if(closestTarget) {
                        if (unit.x < this.WALL_WIDTH && closestTarget.x > this.WALL_WIDTH + this.MOAT_WIDTH) { targetPos = bridgeCenter; } else { targetPos = {x: closestTarget.x, y: closestTarget.y}; }
                    }
                }
                if (targetPos) {
                    const dx = targetPos.x - unit.x; const dy = targetPos.y - unit.y; const dist = Math.sqrt(dx * dx + dy * dy);
                    if (dist > unit.speed) { unit.x += (dx / dist) * unit.speed; unit.y += (dy / dist) * unit.speed; }
                    if (unit.x < 2) unit.x = 2;
                }
            }
        }
    },
    
    applySeparation: function(units) { 
        for (let i = 0; i < units.length; i++) {
            for (let j = i + 1; j < units.length; j++) {
                const u1 = units[i]; const u2 = units[j]; const dx = u2.x - u1.x; const dy = u2.y - u1.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                if (distance > 0 && distance < this.SEPARATION_RADIUS) {
                    const overlap = (this.SEPARATION_RADIUS - distance) / 2; const pushX = (dx / distance) * overlap; const pushY = (dy / distance) * overlap;
                    u1.x -= pushX; u1.y -= pushY; u2.x += pushX; u2.y += pushY;
                }
            }
        }
    },
    
    isTargetValid: function(target) {
        return this.enemyUnits.includes(target) || this.enemyCamps.includes(target);
    },

    updateProjectiles: function() { 
        for (let i = this.projectiles.length - 1; i >= 0; i--) {
            const p = this.projectiles[i]; const target = p.target;
            if (!this.isTargetValid(target)) { this.projectiles.splice(i, 1); continue; }

            const dx = target.x - p.x; const dy = target.y - p.y; const dist = Math.sqrt(dx * dx + dy * dy);
            if (dist < p.speed) {
                if(p.type === 'cannon'){
                    this.effects.push({ x: target.x, y: target.y, radius: p.splashRadius, maxRadius: p.splashRadius, duration: 20, maxDuration: 20, color: 'rgba(255, 165, 0, 0.5)' });
                    const splashTargets = [...this.enemyUnits, ...this.enemyCamps];
                    for(const splashTarget of splashTargets){
                        if(splashTarget.type !== 'flyer'){
                            const splashDist = Math.sqrt(Math.pow(splashTarget.x - target.x, 2) + Math.pow(splashTarget.y - target.y, 2));
                            if(splashDist < p.splashRadius){ splashTarget.health -= p.damage; }
                        }
                    }
                } else { target.health -= p.damage; }
                
                for(let j = this.enemyUnits.length - 1; j >= 0; j--){
                    if(this.enemyUnits[j].health <= 0){ this.coins++; this.enemyUnits.splice(j, 1); }
                }
                this.projectiles.splice(i, 1);
            } else { p.x += (dx / dist) * p.speed; p.y += (dy / dist) * p.speed; }
        }
    },

    updateEffects: function() {
        for (let i = this.effects.length - 1; i >= 0; i--) {
            const effect = this.effects[i];
            effect.duration--;
            if(effect.duration <= 0) { this.effects.splice(i, 1); }
        }
    },

    // --- Drawing Functions ---
    draw: function() {
        this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
        this.drawScenery(); 
        this.drawEnemyCamps(); 
        this.drawPlayerCamps(); 
        this.drawPlayerTowers(); 
        this.drawPlayerUnits();
        this.drawEnemies(); 
        this.drawProjectiles(); 
        this.drawEffects(); 
        this.drawUI();
    },

    drawScenery: function() { 
        this.ctx.fillStyle = '#4682B4'; this.ctx.fillRect(this.WALL_WIDTH, 0, this.MOAT_WIDTH, this.canvas.height);
        this.ctx.fillStyle = '#D2B48C'; this.ctx.fillRect(this.WALL_WIDTH, this.BRIDGE_Y, this.MOAT_WIDTH, this.BRIDGE_HEIGHT);
        this.ctx.fillStyle = '#A9A9A9'; this.ctx.fillRect(0, 0, this.WALL_WIDTH, this.canvas.height);
        this.ctx.fillStyle = '#8B4513'; this.ctx.fillRect(0, 0, 20, this.canvas.height);
    },
    
    drawEnemyCamps: function() {
        for (const camp of this.enemyCamps) {
            const healthPercentage = camp.health / camp.maxHealth;
            this.ctx.fillStyle = 'black'; this.ctx.fillRect(camp.x - 12, camp.y - 18, 24, 5);
            this.ctx.fillStyle = 'orange'; this.ctx.fillRect(camp.x - 12, camp.y - 18, 24 * healthPercentage, 5);
            
            this.ctx.fillStyle = '#8B4513'; 
            this.ctx.fillRect(camp.x - 10, camp.y - 10, 20, 20);
            this.ctx.fillStyle = '#A0522D'; 
            this.ctx.beginPath();
            this.ctx.moveTo(camp.x - 12, camp.y - 9);
            this.ctx.lineTo(camp.x, camp.y - 18);
            this.ctx.lineTo(camp.x + 12, camp.y - 9);
            this.ctx.closePath();
            this.ctx.fill();
        }
    },

    drawPlayerCamps: function() {
        for (const camp of this.playerCamps) {
            const healthPercentage = camp.health / camp.maxHealth;
            // Health bar
            this.ctx.fillStyle = 'black'; this.ctx.fillRect(camp.x - 12, camp.y - 18, 24, 5);
            this.ctx.fillStyle = 'green'; this.ctx.fillRect(camp.x - 12, camp.y - 18, 24 * healthPercentage, 5);
            
            // Camp structure (blue theme)
            this.ctx.fillStyle = '#607D8B'; // Blue Grey
            this.ctx.fillRect(camp.x - 10, camp.y - 10, 20, 20);
            this.ctx.fillStyle = '#455A64'; // Darker Blue Grey
            this.ctx.beginPath();
            this.ctx.moveTo(camp.x - 12, camp.y - 9);
            this.ctx.lineTo(camp.x, camp.y - 18);
            this.ctx.lineTo(camp.x + 12, camp.y - 9);
            this.ctx.closePath();
            this.ctx.fill();
        }
    },

    drawPlayerTowers: function() {
        for(const tower of this.playerTowers) {
            const healthPercentage = tower.health / tower.maxHealth;
            this.ctx.fillStyle = 'black'; this.ctx.fillRect(tower.x - 7, tower.y - 12, 14, 4);
            this.ctx.fillStyle = 'green'; this.ctx.fillRect(tower.x - 7, tower.y - 12, 14 * healthPercentage, 4);
            
            this.ctx.fillStyle = '#666'; this.ctx.fillRect(tower.x - 7, tower.y - 7, 14, 14);
            if(tower.type === 'arrow') { this.ctx.fillStyle = '#888'; }
            else if(tower.type === 'cannon') { this.ctx.fillStyle = '#444'; }
            else if(tower.type === 'slow') { this.ctx.fillStyle = '#add8e6'; }
            this.ctx.fillRect(tower.x - 5, tower.y - 5, 10, 10);
            
            if(this.selectedTower === tower){
                this.ctx.strokeStyle = tower.type === 'slow' ? 'rgba(100,100,255,0.7)' : 'rgba(255,255,255,0.7)';
                this.ctx.lineWidth = 1; this.ctx.beginPath(); this.ctx.arc(tower.x, tower.y, tower.range, 0, Math.PI * 2); this.ctx.stroke();
                this.drawUpgradeUI(tower);
            }
        }
    },
    
    drawUpgradeUI: function(tower){
        if((tower.type === 'slow' || tower.type === 'cannon') && tower.level >= 4) return;
        if(tower.type === 'arrow' && tower.level >= 5) return;
        const cost = 10 * Math.pow(2, tower.level);
        const btn = {x: tower.x + 15, y: tower.y - 25, w: 90, h: 20};
        tower.upgradeButtonRect = btn; 

        this.ctx.fillStyle = this.coins >= cost ? 'rgba(200, 255, 200, 0.9)' : 'rgba(255, 200, 200, 0.9)';
        this.ctx.fillRect(btn.x, btn.y, btn.w, btn.h);
        this.ctx.fillStyle = 'black'; this.ctx.font = '10px monospace';
        this.ctx.fillText(`Lvl ${tower.level} -> ${tower.level + 1}`, btn.x + 5, btn.y + 7);
        this.ctx.fillText(`(${cost}c)`, btn.x + 15, btn.y + 16);
    },

    drawPlayerUnits: function() { 
        for (const unit of this.playerUnits) {
            const healthPercentage = unit.health / 30;
            this.ctx.fillStyle = 'red'; this.ctx.fillRect(unit.x - 5, unit.y - 7, 10, 3);
            this.ctx.fillStyle = 'green'; this.ctx.fillRect(unit.x - 5, unit.y - 7, 10 * healthPercentage, 3);
            this.ctx.fillStyle = 'blue';
            if (unit.type === 'melee') { this.ctx.fillRect(unit.x -1, unit.y -1, 3, 3); }
        }
    },

    drawEnemies: function() { 
        for (const enemy of this.enemyUnits) {
            this.ctx.globalAlpha = enemy.type === 'flyer' ? 0.7 : 1.0;
            const healthPercentage = enemy.health / enemy.maxHealth;
            this.ctx.fillStyle = 'black'; this.ctx.fillRect(enemy.x - 5, enemy.y - 7, 10, 3);
            this.ctx.fillStyle = enemy.type === 'tank' ? '#ff6347' : 'orange'; this.ctx.fillRect(enemy.x - 5, enemy.y - 7, 10 * healthPercentage, 3);
            this.ctx.fillStyle = enemy.type === 'tank' ? '#8B0000' : (enemy.type === 'speedy' ? '#FFD700' : (enemy.type === 'flyer' ? '#E6E6FA' : 'red'));
            if(enemy.currentSpeed < enemy.baseSpeed) this.ctx.fillStyle = '#ADD8E6';
            const size = enemy.type === 'tank' ? 6 : (enemy.type === 'speedy' ? 3 : (enemy.type === 'flyer' ? 5 : 4));
            this.ctx.fillRect(enemy.x-Math.floor(size/2), enemy.y-Math.floor(size/2), size, size);
            if(enemy.type === 'flyer') {
                this.ctx.fillStyle = 'rgba(0,0,0,0.2)';
                this.ctx.beginPath();
                this.ctx.ellipse(enemy.x, enemy.y + 8, 4, 2, 0, 0, Math.PI * 2);
                this.ctx.fill();
            }
            this.ctx.globalAlpha = 1.0;
        }
    },
    
    drawProjectiles: function() { 
        for (const p of this.projectiles){
            this.ctx.fillStyle = p.type === 'cannon' ? 'black' : '#333';
            const size = p.type === 'cannon' ? 3 : 2;
            this.ctx.fillRect(p.x - 1, p.y - 1, size, size);
        }
    },
    
    drawEffects: function() {
        for(const effect of this.effects){
            this.ctx.fillStyle = effect.color || 'rgba(255, 165, 0, 0.5)';
            const maxDuration = effect.maxDuration || 20; 
            const radiusMultiplier = (maxDuration - effect.duration) / maxDuration;
            const currentRadius = effect.radius * radiusMultiplier;
            if (currentRadius > 0) {
                this.ctx.beginPath();
                this.ctx.arc(effect.x, effect.y, currentRadius, 0, Math.PI * 2);
                this.ctx.fill();
            }
        }
    },

    drawUI: function() {
        if(this.buildMode){
            this.ctx.globalAlpha = 0.5;
            this.ctx.fillStyle = '#fff';
            let size = this.buildMode === 'playerCamp' ? 20 : 14;
            this.ctx.fillRect(this.mousePos.x - size/2, this.mousePos.y - size/2, size, size);
            this.ctx.globalAlpha = 1.0;
        }
        document.getElementById('health-stat').textContent = this.baseHealth;
        document.getElementById('coins-stat').textContent = this.coins;
        document.getElementById('wave-stat').textContent = this.waveNumber;
    },
    
    addUnit: function(type, x, y) { 
        if (type === 'melee') {
            const isManualSpawn = (x === undefined || y === undefined);
            if (isManualSpawn) {
                if (this.coins >= 5) {
                    this.coins -= 5;
                    const placementX = this.WALL_WIDTH - 10;
                    x = Math.random() * placementX;
                    y = Math.random() * this.canvas.height;
                } else {
                    return; // Not enough coins for manual spawn
                }
            }
            this.playerUnits.push({ x: x, y: y, type: 'melee', health: 30, speed: 1, detectionRange: 150, manualTarget: null, attackCooldown: 0 });
        }
    },

    gameOver: function() { 
        cancelAnimationFrame(this.gameLoopId);
        this.ctx.fillStyle = 'rgba(0, 0, 0, 0.7)'; this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
        this.ctx.fillStyle = 'white'; this.ctx.font = '30px monospace'; this.ctx.textAlign = 'center';
        this.ctx.fillText('GAME OVER', this.canvas.width / 2, this.canvas.height / 2);
    },

    destroy: function() { 
        console.log(`bitDefenderGame: Destroying.`);
        if (this.gameLoopId) cancelAnimationFrame(this.gameLoopId);
        if (this.container) this.container.innerHTML = '';
        Object.assign(this, {
            canvas: null, ctx: null, gameLoopId: null, playerUnits: [], playerTowers: [], playerCamps: [], enemyUnits: [], enemyCamps: [], projectiles: [], effects: [], coins: 120, baseHealth: 100,
            waveNumber: 0, waveTimer: 450, campSpawnTimer: 1200, spawnTimer: 0, enemiesToSpawn: 0, buildMode: null, selectedTower: null,
            isDragging: false, mousePos: { x: 0, y: 0 }, gameSpeed: 1
        });
    }
};

