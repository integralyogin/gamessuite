{
"Lambda Calculus": { "quote": "λx.M represents function abstraction: parameter x and body M" },
"Alpha Conversion": { "quote": "λx.x ≡ λy.y: renaming bound variables preserves meaning" },
"Beta Reduction": { "quote": "(λx.M)N → M[x:=N]: applying function to argument" },
"Eta Conversion": { "quote": "λx.(fx) ≡ f: extensional equality of functions" },
"Church Numerals": { "quote": "n = λf.λx.f^n(x): representing numbers as functions" },
"Church Booleans": { "quote": "true = λx.λy.x, false = λx.λy.y: logic as functions" },
"Church Pairs": { "quote": "pair = λx.λy.λf.fxy: data structures as functions" },
"Fixed-Point Combinators": { "quote": "Y = λf.(λx.f(xx))(λx.f(xx)): enables recursion" },
"Lambda Terms": { "quote": "Variables, abstractions (λx.M), applications ((MN))" },
"Normal Forms": { "quote": "Terms with no possible beta reductions" },
"Church-Rosser Theorem": { "quote": "Confluence: reduction order doesn't affect result" },
"Currying": { "quote": "f(x,y) → f(x)(y): multi-arg functions as nested singles" },
"Anonymous Functions": { "quote": "x -> x + 1: unnamed function definitions" },
"Higher-Order Functions": { "quote": "Functions that take/return other functions" },
"Pure Functions": { "quote": "Same inputs always produce same outputs" },
"Function Composition": { "quote": "f ∘ g = λx.f(g(x)): combining functions" },
"Partial Application": { "quote": "Fixing some arguments of a function" },
"Lazy Evaluation": { "quote": "Delaying computation until needed" },
"Lambda Abstractions": { "quote": "Creating function objects at runtime" },
"Closure": { "quote": "Function with its lexical environment" },
"Lambda Architecture": { "quote": "Batch and stream processing paradigm" },
"AWS Lambda": { "quote": "Serverless compute service" },
"Lambda Expressions": { "quote": "Syntax for anonymous functions in programming" },
"Capture Avoidance": { "quote": "Preventing variable name conflicts in substitution" },
"Combinatory Logic": { "quote": "Alternative to lambda calculus with combinators" },
"Type Systems": { "quote": "Adding types to lambda calculus" },
"Lambda Lifting": { "quote": "Converting local functions to top-level" },
"Pattern Matching": { "quote": "Destructuring in functional programming" },
"Tail Recursion": { "quote": "Recursive calls in tail position" },
"Monads": { "quote": "Abstracting computational effects" }
}
