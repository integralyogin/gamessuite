{
"Type Systems": { "quote": "A type system is a tractable syntactic method for proving the absence of certain program behaviors by classifying phrases according to the kinds of values they compute." },
"Static vs. Dynamic Typing": { "quote": "Static typing catches errors at compile time; dynamic typing performs checks at runtime. Each offers different tradeoffs between safety, flexibility, and performance." },
"Type Safety": { "quote": "A language is type-safe if the only operations that can be performed on data are those sanctioned by the data's type." },
"Progress and Preservation": { "quote": "The fundamental properties of type systems: well-typed programs make progress (don't get stuck), and the types of expressions are preserved by evaluation." },
"Lambda Calculus": { "quote": "The lambda calculus forms a mathematical foundation for functional programming, with its three basic elements: variables, abstraction (functions), and application." },
"Type Inference": { "quote": "The process of automatically determining the types of expressions without requiring explicit type annotations, using algorithms like Hindley-Milner." },
"Subtyping": { "quote": "A subtype relation allows a term of one type to be safely used in contexts where another type is expected. If S is a subtype of T, written S <: T, then terms of type S can be used wherever terms of type T are expected." },
"Polymorphism": { "quote": "Parametric polymorphism allows a function to work on values of many types; ad-hoc polymorphism (overloading) uses the same notation for different functions; subtype polymorphism relies on subtype relations." },
"Type Operators": { "quote": "Functions from types to types, such as list, array, or dictionary constructors, which take a type parameter and yield a new type." },
"Recursive Types": { "quote": "Types defined in terms of themselves, essential for data structures like lists and trees: T = A + (T × T)." },
"Universal Types": { "quote": "Types of the form ∀X.T, allowing functions to operate uniformly on any type substituted for the type variable X, forming the basis for parametric polymorphism." },
"Existential Types": { "quote": "Types of the form ∃X.T, allowing abstraction over implementation details by hiding concrete types, essential for data abstraction and modules." },
"Nominal vs. Structural Types": { "quote": "Nominal typing distinguishes types by their names; structural typing considers only the structure or shape of types when determining compatibility." },
"Type Checking": { "quote": "The process of verifying that a program obeys the type system's rules, typically performed by traversing the abstract syntax tree and applying typing rules." },
"Simply Typed Lambda Calculus": { "quote": "An extension of the lambda calculus with simple types, providing a foundation for studying type systems in programming languages." },
"System F": { "quote": "The polymorphic lambda calculus, extending the simply typed lambda calculus with universal quantification over types, enabling parametric polymorphism." },
"Hindley-Milner Type System": { "quote": "A type system with parametric polymorphism and type inference, used in ML-family languages, offering a balance between expressiveness and decidable type checking." },
"Sum Types": { "quote": "Types representing values that could be one of several alternatives (A | B), implemented as tagged unions or variant records in many languages." },
"Product Types": { "quote": "Types representing values that contain multiple components simultaneously (A × B), implemented as tuples, records, or structures." },
"Dependent Types": { "quote": "Types that depend on values, allowing for more precise specifications and proving more properties statically, as seen in languages like Coq and Agda." },
"Operational Semantics": { "quote": "A way of defining program behavior by specifying state transitions, either through small-step (showing each computational step) or big-step (showing direct evaluation to final results) relations." },
"Denotational Semantics": { "quote": "The approach to defining meaning by mapping program constructs to mathematical objects that represent their meaning or effect." },
"Axiomatic Semantics": { "quote": "Defining program meaning through logical assertions about program states before and after execution, central to formal verification techniques like Hoare logic." },
"Type Soundness": { "quote": "The property that well-typed programs cannot encounter certain classes of runtime errors, typically proven through progress and preservation theorems." },
"Type Reconstruction": { "quote": "The process of inferring a minimal type for a program without type annotations, a key feature of the ML family of programming languages." },
"Higher-Kinded Types": { "quote": "Types of types, or type constructors, that abstract over type constructors rather than just types, enabling more general polymorphic abstractions." },
"Linear Types": { "quote": "Types that ensure resources are used exactly once, providing static guarantees for resource management without garbage collection or reference counting." },
"Intersection Types": { "quote": "Types of the form A ∧ B, requiring a term to satisfy both type A and type B simultaneously, useful for typing overloaded functions." },
"Union Types": { "quote": "Types of the form A ∨ B, allowing a term to satisfy either type A or type B, providing flexibility while maintaining type safety." },
"Gradual Typing": { "quote": "A type system approach that allows both statically typed and dynamically typed code to coexist and interoperate in the same program, enabling incremental addition of types to dynamic languages." }
}
