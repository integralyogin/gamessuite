{  
  "Interface Abstraction": { "quote": "Depend on interfaces, not implementations: IRenderer → DirectX/Vulkan/Metal implementations." },  
  "Dependency Inversion": { "quote": "High-level modules define abstractions; low-level modules implement them (SOLID’s 'D' principle)." },  
  "Pub/Sub Communication": { "quote": "Modules emit events (e.g., OnPhysicsStep) without direct coupling: EventBus.Publish(Event)." },  
  "Messaging Queues": { "quote": "Decoupled IPC: Physics thread → Render thread via MessageQueue.Push(TransformUpdate)." },  
  "Plugin Architecture": { "quote": "Dynamic libraries: Load DLLs/so at runtime (e.g., Godot’s GDNative, Unreal plugins)." },  
  "Facade Pattern": { "quote": "Unify subsystems: GameEngineFacade.Start() → Initializes Audio, Physics, UI behind a simple API." },  
  "Service Locator": { "quote": "Global access without tight coupling: ServiceLocator.Get<IAudioService>().PlaySound();" },  
  "Dependency Injection": { "quote": "Constructor injection: class PhysicsSystem { PhysicsSystem(ICollisionSolver solver) }." },  
  "Layered Architecture": { "quote": "Presentation → Business → Data layers (e.g., UI never directly queries databases)." },  
  "API Gateways": { "quote": "REST/gRPC boundaries: Microservices expose APIs, hide internal logic (e.g., AuthService)." },  
  "Contract Testing": { "quote": "Verify interfaces: Pact tests ensure modules adhere to agreed-upon API schemas." },  
  "Module Boundaries": { "quote": "Enforce via namespaces/packages: Unity’s Assembly Definitions → Compile-time isolation." },  
  "Shared Nothing": { "quote": "Minimize cross-module state: PhysicsModule owns rigidbody data; UIModule owns HUD state." },  
  "Event Sourcing": { "quote": "Modules react to immutable event logs: InputSystem → Emits PlayerJumpEvent → Physics/Audio consume." },  
  "Hexagonal Architecture": { "quote": "Core logic ↔ Adapters: Game rules stay pure; platform-specific I/O (file, network) adapt outward." },  
  "Unit Testing": { "quote": "Mock dependencies: when(PhysicsMock.Collide()).thenReturn(true); → Test in isolation." },  
  "Versioned Interfaces": { "quote": "Semantic versioning: v1.PhysicsAPI → v2.PhysicsAPI with backward compatibility." },  
  "Build System Decoupling": { "quote": "CMake/FAKE scripts: Compile modules independently (e.g., rebuild Audio without touching UI)." },  
  "Case Study: CryEngine": { "quote": "Hot-reload: Edit C++ code → Recompile DLL → Reload without restarting the editor." },  
  "Case Study: Unity Packages": { "quote": "URP (Universal Render Pipeline): Swap rendering modules without breaking gameplay code." },  
  "Case Study: Unreal Engine": { "quote": "Slate UI framework: Editor tools decoupled from runtime gameplay systems." },  
  "Design by Contract": { "quote": "Preconditions/Postconditions: requires(position != null) → ensures(speed > 0)." },  
  "Cross-Module Debugging": { "quote": "Tracing: Correlate logs via request IDs (e.g., TraceID=ABC123 spans Physics → Renderer)." },  
  "Legacy Wrappers": { "quote": "Adapter pattern: LegacyPhysics → NewPhysicsAPI via wrapper class (e.g., Box2D to PhysX)." },  
  "Documentation Contracts": { "quote": "OpenAPI/Swagger: Define module APIs upfront → Teams develop in parallel." },  
  "Future Trends": { "quote": "AI-driven decoupling: LLMs analyze codebases → Suggest modular boundaries (GitHub Copilot)." },  
  "Cultural Wisdom": { "quote": "“If you think good architecture is expensive, try bad architecture.” (Brian Foote & Joseph Yoder)." }  
}  
