{
"Classes": { "quote": "Blueprint for objects: class Car { properties; methods; }" },
"Objects": { "quote": "Instances of classes: myCar = new Car(); represents real-world entities" },
"Encapsulation": { "quote": "Bundling data and methods: private variables, public interfaces" },
"Inheritance": { "quote": "Class hierarchies: class ElectricCar extends Car { additional features }" },
"Polymorphism": { "quote": "Many forms of methods: override drive() for different vehicle types" },
"Abstraction": { "quote": "Hiding complexity: abstract class Vehicle defines common interface" },
"Methods": { "quote": "Object behaviors: public void start() { implementation details }" },
"Properties": { "quote": "Object attributes: private String color; private int speed;" },
"Constructors": { "quote": "Object initialization: public Car(String model) { this.model = model; }" },
"Interfaces": { "quote": "Contract for implementation: interface Driveable { void drive(); }" },
"Access Modifiers": { "quote": "Visibility control: public, private, protected, package-private" },
"Instance Variables": { "quote": "Object-specific data: each object has its own copy" },
"Static Members": { "quote": "Class-level elements: shared across all instances" },
"Method Overloading": { "quote": "Multiple method versions: drive() vs drive(int speed)" },
"Method Overriding": { "quote": "Replacing inherited methods: @Override indicates intention" },
"Association": { "quote": "Object relationships: Car has-a Engine, Driver drives-a Car" },
"Aggregation": { "quote": "Weak containment: Department has Students, but Students can exist independently" },
"Composition": { "quote": "Strong containment: Car has Engine, Engine cannot exist without Car" },
"Abstract Classes": { "quote": "Partial implementation: some methods defined, others abstract" },
"Final Classes": { "quote": "Preventing inheritance: final class cannot be extended" },
"Virtual Methods": { "quote": "Runtime polymorphism: method binding decided at runtime" },
"Message Passing": { "quote": "Objects communicate: object.method(parameters)" },
"Delegation": { "quote": "Object forwarding requests: wrapper.method() calls wrapped.method()" },
"Cohesion": { "quote": "Related functionality grouped: class focuses on single responsibility" },
"Coupling": { "quote": "Dependency between classes: minimize connections for better design" },
"Design Patterns": { "quote": "Reusable solutions: Singleton, Factory, Observer patterns" },
"SOLID Principles": { "quote": "Design guidelines: Single Responsibility, Open-Closed, etc." },
"Exception Handling": { "quote": "Error management: try-catch blocks for robust code" },
"Object Lifecycle": { "quote": "Creation to destruction: constructor, garbage collection" },
"Type System": { "quote": "Object classification: static vs dynamic typing" }
}
