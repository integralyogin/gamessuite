{
"Divide and Conquer": { "quote": "Break problem into smaller subproblems, solve recursively, combine results. Example: Mergesort O(n log n)." },
"Dynamic Programming": { "quote": "Store subproblem solutions to avoid recomputation. Example: Fibonacci F(n) = F(n-1) + F(n-2)." },
"Greedy Algorithms": { "quote": "Make locally optimal choices at each step. Example: Dijkstra's shortest path algorithm." },
"Backtracking": { "quote": "Systematically explore solution space, abandoning unpromising paths. Example: N-Queens problem." },
"Branch and Bound": { "quote": "Systematically enumerate candidates, prune using bounds. Example: Traveling Salesman Problem." },
"Graph Algorithms": { "quote": "Process vertex-edge relationships. Example: Depth-First Search traverses deeply before backtracking." },
"String Algorithms": { "quote": "Process text and patterns. Example: KMP pattern matching in O(n+m) time." },
"Computational Geometry": { "quote": "Solve geometric problems. Example: Graham Scan for convex hull in O(n log n)." },
"Network Flow": { "quote": "Optimize flow through networks. Example: Ford-Fulkerson maximum flow algorithm." },
"Linear Programming": { "quote": "Optimize linear objective subject to linear constraints. Example: Simplex method." },
"Approximation Algorithms": { "quote": "Find near-optimal solutions for NP-hard problems. Example: Vertex Cover 2-approximation." },
"Randomized Algorithms": { "quote": "Use random choices for efficiency. Example: QuickSort with random pivot selection." },
"Online Algorithms": { "quote": "Process input piece-by-piece in serial fashion. Example: Paging algorithms." },
"Parallel Algorithms": { "quote": "Execute multiple operations simultaneously. Example: Parallel merge sort." },
"Distributed Algorithms": { "quote": "Solve problems across multiple processors. Example: Distributed consensus protocols." },
"Space-Time Tradeoff": { "quote": "Balance memory usage versus computation time. Example: Hash tables vs. search trees." },
"Problem Reduction": { "quote": "Transform one problem into another. Example: Reduction of 3-SAT to Independent Set." },
"State Space Search": { "quote": "Explore possible states systematically. Example: A* search algorithm." },
"Pattern Matching": { "quote": "Find occurrences of patterns. Example: Regular expression matching." },
"Recursive Design": { "quote": "Solutions built from solutions to smaller instances. Example: Tower of Hanoi." },
"Iterative Design": { "quote": "Solutions built through repeated refinement. Example: Binary search." },
"Amortized Analysis": { "quote": "Average performance over sequence of operations. Example: Dynamic array resizing." },
"Probabilistic Analysis": { "quote": "Expected performance under random input. Example: Skip lists." },
"Complexity Classes": { "quote": "Categorize problems by resource requirements. Example: P vs NP classification." },
"Algorithm Analysis": { "quote": "Evaluate resource usage and efficiency. Example: Big-O notation O(n)." },
"Data Structure Design": { "quote": "Organize data for efficient operations. Example: Self-balancing BST." },
"Optimization Techniques": { "quote": "Improve algorithm efficiency. Example: Loop unrolling, tail recursion." },
"Error Handling": { "quote": "Manage and recover from exceptional cases. Example: Input validation strategies." },
"Testing Strategies": { "quote": "Verify algorithm correctness. Example: Edge case testing, stress testing." },
"Performance Tuning": { "quote": "Optimize practical implementation. Example: Cache-friendly access patterns." }
}
