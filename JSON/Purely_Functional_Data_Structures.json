{
"Persistent Data Structures": { "quote": "Purely functional data structures are always persistent: operations that seem to 'modify' the structure actually create a new version, leaving the old structure intact." },
"Amortization": { "quote": "Amortized data structures guarantee good performance when operations are considered in sequence rather than individually." },
"Lazy Evaluation": { "quote": "Lazy evaluation defers computation until results are needed, enabling more efficient algorithms and elegant solutions to complex problems." },
"Structural Sharing": { "quote": "New versions of data structures can share significant portions of their structure with old versions, reducing memory usage." },
"Path Copying": { "quote": "When modifying a node in a tree, create new nodes along the path from the root to that node while sharing unmodified subtrees." },
"Bootstrapping": { "quote": "A technique where a data structure uses a smaller instance of itself to improve its own performance." },
"Streams": { "quote": "Potentially infinite lists where elements are evaluated only as needed, combining lazy evaluation with recursive definitions." },
"Functional Queues": { "quote": "Efficient queue implementations using two lists: one for front elements and one for rear elements, with occasional reorganization." },
"Red-Black Trees": { "quote": "Self-balancing binary search trees that maintain their balance through color properties and rotations during insertion and deletion." },
"Weight-Balanced Trees": { "quote": "Trees that maintain balance by tracking the sizes of subtrees rather than their heights." },
"Banker's Method": { "quote": "An accounting method for analyzing amortized complexity where credits are saved for future expensive operations." },
"Physicist's Method": { "quote": "An analysis technique that uses a potential function to track the 'energy' of a data structure and analyze amortized performance." },
"Memoization": { "quote": "Caching results of function calls to avoid redundant computation, particularly useful with recursion." },
"Schedule-Based Evaluation": { "quote": "A systematic approach to forcing thunks in lazy data structures to maintain amortized bounds." },
"Binomial Heaps": { "quote": "Priority queues composed of binomial trees that support efficient merging operations." },
"Splay Trees": { "quote": "Self-adjusting binary search trees that move recently accessed elements closer to the root." },
"Skew Binomial Heaps": { "quote": "A variant of binomial heaps with improved worst-case performance for certain operations." },
"Batched Rebuilding": { "quote": "Accumulating small changes and occasionally rebuilding the data structure from scratch to maintain balance." },
"Catenable Lists": { "quote": "Lists supporting efficient append operations while maintaining other operations' performance." },
"Real-Time Queues": { "quote": "Queues with guaranteed worst-case bounds rather than amortized bounds, using lazy evaluation and scheduling." },
"Deques": { "quote": "Double-ended queues supporting efficient insertion and deletion at both ends." },
"Random-Access Sequences": { "quote": "Data structures supporting efficient lookups by position while maintaining other list operations." },
"Implicit Recursive Slowdown": { "quote": "A technique that improves the asymptotic complexity of operations by adding an extra layer of recursion." },
"Eliminating Amortization": { "quote": "Converting amortized bounds to worst-case bounds through incremental operations and lazy evaluation." },
"Program Derivation": { "quote": "Systematic transformation of naive but correct algorithms into efficient implementations." },
"Applicative vs. Imperative": { "quote": "Purely functional (applicative) data structures vs. those with side effects (imperative), with trade-offs in simplicity and performance." },
"Strict vs. Lazy Evaluation": { "quote": "Comparing evaluation strategies: strict (eager) evaluation computes results immediately; lazy evaluation defers computation until needed." },
"Numerical Representations": { "quote": "Using number system concepts like binary and decimal to design efficient data structures." },
"Global Rebuilding": { "quote": "Gradually rebuilding an entire data structure in the background to maintain balance with guaranteed bounds." },
"Functional Design Patterns": { "quote": "Recurring techniques in functional data structure design, such as tupling, recursive slowdown, and bootstrapping." }
}
