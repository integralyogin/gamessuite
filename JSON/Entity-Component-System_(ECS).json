{
"Entity": { "quote": "A unique identifier representing a game object with no data or behavior of its own. In Unity DOTS, entities are lightweight IDs that replace traditional GameObject hierarchies." },
"Component": { "quote": "Pure data containers attached to entities that define their properties. In Unreal Engine, components like TransformComponent, MeshComponent, or HealthComponent contain only state data." },
"System": { "quote": "Logic processors that operate on entities with specific component combinations. In EnTT, systems might update physics for all entities with Position and RigidBody components." },
"Composition": { "quote": "Combining components to define an entity's behavior and properties. A game character might be composed of Transform, Sprite, Health, and Input components." },
"Data-Oriented Design": { "quote": "Organizing memory for optimal cache coherency and performance. Unity DOTS organizes components in contiguous arrays for efficient processing." },
"Component Queries": { "quote": "Filtering entities based on component combinations. Bevy's query system lets you process only entities with Position AND Velocity BUT NOT Static components." },
"Archetypes": { "quote": "Groups of entities sharing identical component types. Unity ECS uses archetypes to organize entities with the same component makeup for efficient iteration." },
"Component Pools": { "quote": "Memory management technique for component storage. EnTT uses sparse sets to store components of the same type contiguously in memory." },
"World": { "quote": "Container for all entities, components, and systems. In Flecs, the world manages entity creation and component registration throughout the application lifecycle." },
"System Execution Order": { "quote": "Managing the sequence of system updates. Unity's SystemBase classes can define explicit dependencies to ensure correct update order." },
"Events": { "quote": "Communication mechanism between otherwise independent systems. In EnTT, observers can react to component addition, removal, or modification." },
"Resources": { "quote": "Singleton data accessible across multiple systems. Bevy uses resources for global state like time, input, or asset storage." },
"Tags": { "quote": "Empty components used to categorize entities. Unity DOTS uses tag components like Enemy or Projectile to identify entity roles without additional data." },
"Dynamic Composition": { "quote": "Adding and removing components at runtime to change entity behavior. In many ECS frameworks, turning a normal NPC into an enemy might involve adding an Aggressive component." },
"Hierarchies": { "quote": "Parent-child relationships between entities. Flecs implements hierarchies through special relationship components." },
"Component Buffers": { "quote": "Collections of similar components attached to a single entity. Unity DOTS' DynamicBuffer allows entities to have multiple instances of a component type." },
"Prefabs": { "quote": "Templates for entity creation with predefined component sets. Bevy's prefab system allows for quick instantiation of common entity types." },
"System Groups": { "quote": "Organization of systems into logical collections. Unity ECS uses system groups like InitializationSystemGroup and SimulationSystemGroup to manage execution phases." },
"Serialization": { "quote": "Converting entity and component data for storage or transmission. EnTT supports component serialization for save systems and networking." },
"Chunk Iteration": { "quote": "Processing entities in memory-aligned groups. Unity DOTS processes entities in chunks that share the same archetype for cache efficiency." },
"Queries vs. Views": { "quote": "Different approaches to accessing component data. EnTT distinguishes between views (for known component combinations) and runtime queries for flexibility." },
"Component Dependencies": { "quote": "Relationships between components that affect entity behavior. In some ECS implementations, a Renderer component might depend on a Transform component." },
"Reactive Systems": { "quote": "Systems that execute in response to component changes. Legion supports reactive systems that only run when relevant component data is modified." },
"Shared Components": { "quote": "Components whose data is shared among multiple entities. Unity ECS uses shared components to batch similar entities together, like those sharing the same material." },
"Aspect-Oriented Programming": { "quote": "Cross-cutting concerns that span multiple systems. Some ECS frameworks implement aspects to handle features like logging or networking across systems." },
"Command Buffers": { "quote": "Deferred execution of entity operations. Unity ECS's EntityCommandBuffer allows safe creation and modification of entities from parallel jobs." },
"Job System Integration": { "quote": "Parallelizing system execution across multiple threads. Unity DOTS combines ECS with the C# Job System for high-performance parallel processing." },
"Singleton Entities": { "quote": "Special entities that exist only once in the world. Bevy uses singleton-like resources, while other frameworks might use entities with unique components." },
"Scripting Integration": { "quote": "Connecting ECS architecture with traditional scripting. Unity's hybrid ECS approach allows MonoBehaviours to interact with the ECS world." },
"Performance Considerations": { "quote": "Optimization techniques specific to ECS. Cache-friendly memory layout and avoiding virtual functions are key optimizations in most ECS implementations." }
}
