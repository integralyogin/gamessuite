{
"Command Pattern": { "quote": "Encapsulates a request as an object, thereby letting you parameterize clients with different requests, queue or log requests, and support undoable operations. Perfect for implementing input handling, AI behaviors, and replay systems." },
"Flyweight Pattern": { "quote": "Uses sharing to support large numbers of fine-grained objects efficiently. When your game needs thousands of similar objects like particles, tiles, or units, flyweights help minimize memory usage." },
"Observer Pattern": { "quote": "Defines a one-to-many dependency between objects so that when one object changes state, all its dependents are notified and updated automatically. Ideal for event systems, UI updates, and achievement tracking." },
"Prototype Pattern": { "quote": "Specifies the kinds of objects to create using a prototypical instance, and creates new objects by copying this prototype. Great for implementing prefabs, spawning enemies, or creating variations of similar objects." },
"Singleton Pattern": { "quote": "Ensures a class has only one instance and provides a global point of access to it. Useful for managers and services, but use with caution to avoid global state problems." },
"State Pattern": { "quote": "Allows an object to alter its behavior when its internal state changes. The object will appear to change its class. Perfect for character controllers, game states, and AI behavior." },
"Double Buffer": { "quote": "Prevents flickering by drawing to a back buffer before swapping to the front display buffer. Beyond graphics, useful for any system where you need to present a consistent state while preparing the next one." },
"Game Loop": { "quote": "The central update mechanism that drives the game forward by processing input, updating game state, and rendering at an appropriate pace. Forms the heartbeat of every game." },
"Update Method": { "quote": "Simulates concurrent behavior by giving each object its own update method that gets called each frame. The foundation for most game entity behavior implementations." },
"Bytecode": { "quote": "Creates a custom instruction set and virtual machine to enable data-driven behavior. Useful for scripting systems, moddable content, and portable game logic." },
"Subclass Sandbox": { "quote": "Creates a set of protected operations for subclasses to use, letting derived classes pick and choose behavior while keeping common code in the base class. Great for defining families of similar but varied game objects." },
"Type Object": { "quote": "Creates a class that defines different 'types' of objects rather than using a class hierarchy. Excellent for defining enemy types, item categories, or spell effects without class explosion." },
"Component": { "quote": "Allows composition of behavior by attaching component objects to a core entity. The backbone of modern game engines, enabling flexible game object models without deep inheritance hierarchies." },
"Event Queue": { "quote": "Decouples when something happens from when it's processed by storing events in a queue. Perfect for handling input, audio triggering, and cross-system communication." },
"Service Locator": { "quote": "Provides a global point of access to a service without coupling users to the concrete class that implements it. Useful for audio systems, physics engines, and other game services." },
"Data Locality": { "quote": "Organizes data to take advantage of CPU caching and minimize cache misses. Critical for performance-intensive systems like particle effects or physics simulations." },
"Dirty Flag": { "quote": "Avoids unnecessary work by deferring expensive calculations until results are needed and only recalculating when inputs have changed. Great for derived data like world transforms or visibility determination." },
"Object Pool": { "quote": "Recycles objects instead of allocating/deallocating them to improve performance and reduce memory fragmentation. Essential for frequently created/destroyed objects like projectiles, particles, and enemies." },
"Spatial Partition": { "quote": "Divides space into regions to efficiently locate objects by limiting the number of entities that need to be checked for collision or visibility. Underpins collision detection, AI awareness, and rendering optimization." },
"Optimization Patterns": { "quote": "Focus on what's actually slowing your game down, not what you think is slow. Profile before optimizing, and remember that the best code is often the code you don't write." },
"Sequencing Patterns": { "quote": "Control the order and timing of complex game behavior and object interactions without creating tangled dependencies between systems." },
"Behavioral Patterns": { "quote": "Define clear, reusable ways for objects to interact, enabling complex behaviors to emerge from simple components working together." },
"Decoupling Patterns": { "quote": "Reduce dependencies between systems to improve code flexibility, maintainability, and reusability as the game grows in complexity." },
"Architectural Patterns": { "quote": "Define the overall structure of your game code to keep it organized, maintainable, and adaptable as requirements evolve during development." },
"Design Patterns": { "quote": "Not about finding the 'right' pattern, but about communicating intent clearly. The best pattern is the one that solves your specific problem while fitting naturally into your codebase." }
}
