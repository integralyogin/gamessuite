{
"Automata Theory": { "quote": "Study of abstract machines: Input → States → Output" },
"Finite Automata": { "quote": "DFA: (Q, Σ, δ, q₀, F) where Q=states, Σ=alphabet, δ=transitions, q₀=start, F=final states" },
"Regular Languages": { "quote": "Languages recognizable by finite automata: (a|b)*abb describes patterns" },
"Regular Expressions": { "quote": "Pattern notation: * for repetition, | for choice, () for grouping" },
"Pushdown Automata": { "quote": "Finite automata + stack memory: Recognizes context-free languages" },
"Context-Free Grammars": { "quote": "S → aSb | ε generates balanced parentheses" },
"Turing Machines": { "quote": "Universal computation model: (Q, Σ, Γ, δ, q₀, q_accept, q_reject)" },
"Church-Turing Thesis": { "quote": "Everything computable is Turing-computable: Algorithm ↔ Turing Machine" },
"Halting Problem": { "quote": "Undecidable whether program halts: No algorithm can decide for all programs" },
"Decidability": { "quote": "Problems solvable by algorithms: ∃TM M that decides language L" },
"Undecidability": { "quote": "Problems with no algorithmic solution: Rice's Theorem - No non-trivial property decidable" },
"Computational Complexity": { "quote": "Resource requirements for problems: Time and space complexity" },
"Time Complexity": { "quote": "Number of steps for computation: O(n) linear, O(n²) quadratic, O(2ⁿ) exponential" },
"Space Complexity": { "quote": "Memory required for computation: O(1) constant, O(log n) logarithmic, O(n) linear" },
"P Class": { "quote": "Problems solvable in polynomial time: TIME(nᵏ) for some k" },
"NP Class": { "quote": "Problems verifiable in polynomial time: Solutions checkable in P" },
"NP-Complete": { "quote": "Hardest problems in NP: SAT is NP-complete (Cook-Levin theorem)" },
"NP-Hard": { "quote": "At least as hard as NP problems: Traveling Salesman Problem" },
"Reduction": { "quote": "Problem A reduces to B: A ≤ₚ B means B at least as hard as A" },
"P vs NP": { "quote": "Fundamental open problem: Are P and NP equal?" },
"Lambda Calculus": { "quote": "Mathematical model of computation: λx.x defines identity function" },
"Recursive Functions": { "quote": "Functions calling themselves: f(n) = f(n-1) + f(n-2)" },
"Computability Theory": { "quote": "What can and cannot be computed: Recursively enumerable sets" },
"Formal Languages": { "quote": "Sets of strings over alphabet: Regular ⊂ Context-Free ⊂ Recursive" },
"State Complexity": { "quote": "Minimum states needed: Myhill-Nerode theorem" },
"Quantum Computation": { "quote": "Quantum mechanical computation model: |ψ⟩ = α|0⟩ + β|1⟩" },
"Parallel Computation": { "quote": "Multiple simultaneous computations: PRAM models" },
"Circuit Complexity": { "quote": "Computational power of boolean circuits: AC⁰ ⊂ AC¹ ⊂ NC ⊂ P" },
"Randomized Computation": { "quote": "Algorithms using random choices: BPP class" },
"Communication Complexity": { "quote": "Information exchange requirements: Two-party protocols" },
"Descriptive Complexity": { "quote": "Logical descriptions of complexity classes: FO = AC⁰" }
}
