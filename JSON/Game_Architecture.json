{
"Entity Component System": { "quote": "A compositional architecture separating data from behavior. Unity's GameObject-Component model allows flexible entity construction without deep inheritance hierarchies." },
"Game Loop": { "quote": "The core update cycle processing input, updating game state, and rendering. Most games run a loop of: process input, update game state, render, repeat at a fixed or variable timestep." },
"Update Method": { "quote": "Objects receive regular update calls to modify their state. Unreal Engine's Tick() function gives every actor a chance to update each frame." },
"Component Pattern": { "quote": "Composition over inheritance for game object construction. Overwatch uses components for health, movement, abilities, and rendering that can be mixed and matched." },
"Object Pooling": { "quote": "Recycling game objects to avoid expensive instantiation and garbage collection. Bullet hell shooters pre-allocate hundreds of projectiles and reuse them to maintain performance." },
"Dirty Flag": { "quote": "Deferring expensive computations until necessary. Physics engines mark objects as 'dirty' when moved, recalculating collisions only for affected objects." },
"State Pattern": { "quote": "Encapsulating state-specific behavior in separate objects. Character controllers often use state machines for idle, walk, jump, and attack states with clean transitions." },
"Observer Pattern": { "quote": "Objects subscribing to events from other objects. Unity's event system allows UI elements to notify listeners when clicked without direct coupling." },
"Command Pattern": { "quote": "Encapsulating actions as objects for queuing, logging, and undoing. Real-time strategy games use command objects to represent unit orders that can be queued and executed sequentially." },
"Flyweight Pattern": { "quote": "Sharing common data between similar objects. Minecraft uses flyweights to store block type data once while instances only reference the shared data." },
"Spatial Partitioning": { "quote": "Dividing space to efficiently query objects by location. Open world games use quadtrees or spatial hashing to query only objects in the player's vicinity." },
"Data-Oriented Design": { "quote": "Organizing code around data transformation and cache optimization. Modern engines process entities in batches with contiguous memory access for better performance." },
"Scene Graph": { "quote": "Hierarchical organization of game objects. Transform hierarchies in Unity and Unreal let child objects inherit parent position, rotation, and scale." },
"Messaging Systems": { "quote": "Decoupled communication between game subsystems. Event buses in games like The Sims allow AI, animation, and audio systems to coordinate without direct dependencies." },
"Game State Management": { "quote": "Handling transitions between game modes and screens. State stacks elegantly manage menu navigation, allowing pausing, options screens, and seamless returns." },
"Resource Management": { "quote": "Loading, caching, and unloading game assets. Streaming open world games like Red Dead Redemption 2 dynamically load assets based on player proximity." },
"Model-View-Controller": { "quote": "Separating game state, presentation, and input handling. Strategy games often separate unit data (model) from rendering (view) and player commands (controller)." },
"Bytecode Virtual Machine": { "quote": "Scripting engines for game behavior. Lua VMs in games like World of Warcraft enable modding and separate game logic from engine code." },
"Component-Based Rendering": { "quote": "Decoupling visual representation from game logic. Rendering components in Overwatch handle appearances while gameplay components manage behavior." },
"Behavior Trees": { "quote": "Hierarchical structures for AI decision making. The Last of Us uses behavior trees with fallbacks and sequences for enemy AI that responds to changing situations." },
"Dependency Injection": { "quote": "Providing external dependencies to components. Modern game frameworks use service locators or injection to provide physics, audio, or networking services to components." },
"Double Buffer": { "quote": "Using two buffers to prevent visual artifacts during updates. Game renderers swap between front and back buffers to display complete frames without tearing." },
"Singleton": { "quote": "Ensuring a class has only one instance with global access. Game managers for audio, input, or scenes often use singletons for centralized control." },
"Dirty Rectangle": { "quote": "Updating only changed portions of the screen. 2D games like Terraria track modified areas to avoid redrawing the entire screen." },
"Component Communication": { "quote": "Methods for components to interact within an entity. Godot's signal system lets components notify each other of events without direct references." },
"Data-Driven Design": { "quote": "Defining game behavior through data rather than code. Games like Civilization store unit statistics, abilities, and behaviors in data files for easy balancing." },
"Scripting Layer": { "quote": "Separating engine from game-specific logic. Unity and Unreal provide C# and Blueprint scripting layers above their C++ engine cores." },
"Hot Reloading": { "quote": "Updating code or assets without restarting the game. Modern engines allow scripts, shaders, and assets to be modified during play for rapid iteration." },
"Threading Patterns": { "quote": "Distributing work across CPU cores. AAA games use job systems to parallelize physics, AI, and animation across multiple threads." },
"Serialization Systems": { "quote": "Converting game state to persistent formats. Save systems transform complex object graphs into files that can restore the complete game state." }
}
