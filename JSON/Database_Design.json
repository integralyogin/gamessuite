{
"Entity-Relationship Model": { "quote": "A conceptual representation of data objects, their attributes, and relationships. Customer(id, name, email) relates to Order(id, date, total) through a one-to-many relationship." },
"Normalization": { "quote": "The process of organizing data to reduce redundancy and improve integrity. Moving from 1NF to 5NF progressively eliminates anomalies and dependencies." },
"First Normal Form (1NF)": { "quote": "Each column contains atomic values, and each record is unique. Breaking Address(street, city, state, zip) into individual atomic fields." },
"Second Normal Form (2NF)": { "quote": "Meets 1NF and all non-key attributes are fully dependent on the primary key. Moving Order_Items from Orders table to a separate table with Order_ID, Product_ID as composite key." },
"Third Normal Form (3NF)": { "quote": "Meets 2NF and all attributes are directly dependent on the primary key. Moving Customer_State to a States table to eliminate transitive dependencies." },
"BCNF (Boyce-Codd Normal Form)": { "quote": "A stricter version of 3NF where every determinant must be a candidate key. Ensuring Course(CourseID, Professor, Department) properly handles when a professor can teach in multiple departments." },
"Denormalization": { "quote": "The strategic violation of normalization rules to improve read performance. Adding a TotalItems column to Orders table to avoid COUNT queries." },
"Primary Key": { "quote": "A column or combination of columns that uniquely identifies each row. CustomerID as an auto-incrementing integer that serves as the primary key." },
"Foreign Key": { "quote": "A field that links to the primary key of another table. OrderID in the Order_Items table references the Orders table." },
"Indexing": { "quote": "Data structures that improve the speed of data retrieval operations. Creating a B-tree index on LastName for frequent customer searches." },
"Query Optimization": { "quote": "Techniques to improve database query performance. Rewriting 'SELECT * FROM Customers WHERE YEAR(JoinDate) = 2023' to use an indexed column directly." },
"Transactions": { "quote": "A sequence of operations performed as a single logical unit of work. BEGIN; UPDATE Accounts SET Balance = Balance - 100 WHERE ID = 1; UPDATE Accounts SET Balance = Balance + 100 WHERE ID = 2; COMMIT;" },
"ACID Properties": { "quote": "Atomicity, Consistency, Isolation, and Durability guarantee reliable processing of database transactions. All operations in a funds transfer either complete entirely or fail entirely." },
"Data Integrity": { "quote": "Rules that ensure accuracy and consistency of data. CHECK constraints enforce that Price > 0 in a Products table." },
"Referential Integrity": { "quote": "Ensures relationships between tables remain consistent. ON DELETE CASCADE automatically removes order items when an order is deleted." },
"Schema Design": { "quote": "The blueprint of a database's structure including tables, fields, relationships, and constraints. Creating a properly structured schema for an e-commerce system." },
"Data Types": { "quote": "Specific types of data values assigned to columns. Using VARCHAR(50) for names, DECIMAL(10,2) for currency, and DATETIME for timestamps." },
"Database Partitioning": { "quote": "Dividing large tables into smaller, more manageable pieces. Partitioning customer data by region or transaction history by year." },
"Sharding": { "quote": "Horizontal partitioning of data across multiple database instances. Distributing user data across multiple servers based on user_id modulo." },
"Views": { "quote": "Virtual tables based on the result-set of a stored SQL query. Creating a CustomerOrders view joining Customers and Orders tables." },
"Stored Procedures": { "quote": "Prepared SQL code that can be saved and reused. CREATE PROCEDURE GetCustomerOrders(@CustomerID INT) AS SELECT * FROM Orders WHERE CustomerID = @CustomerID;" },
"Triggers": { "quote": "Automated procedures that activate when specific database events occur. Creating an AFTER INSERT trigger to update inventory levels when a new order is placed." },
"NoSQL Design": { "quote": "Non-relational database approaches optimized for specific data models. Using document store for nested customer data with embedded orders." },
"Data Warehousing": { "quote": "Systems designed for query and analysis rather than transaction processing. Creating a star schema with fact and dimension tables for sales analytics." },
"Object-Relational Mapping": { "quote": "Technique for converting data between incompatible type systems in object-oriented programming. Mapping Java Customer class to relational Customers table." },
"Database Security": { "quote": "Protecting data from unauthorized access and ensuring privacy. Implementing role-based access control and column-level encryption for sensitive data." },
"Data Modeling": { "quote": "Process of creating a visual representation of data structures and relationships. Creating conceptual, logical, and physical models for a new system." },
"Query Language": { "quote": "Languages designed for managing and retrieving data from databases. Using SQL's SELECT, JOIN, GROUP BY to analyze customer purchasing patterns." },
"Database Performance": { "quote": "Techniques for optimizing database speed and efficiency. Implementing proper indexing, query optimization, and hardware scaling." },
"Database Replication": { "quote": "Process of copying data from one database to one or more other databases. Setting up master-slave replication for read scalability and failover." }
}
