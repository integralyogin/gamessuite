{
"Computational Processes": { "quote": "Processes are abstract beings that inhabit computers. As they evolve, processes manipulate other abstract things called data." },
"Abstraction": { "quote": "The act of viewing a pattern as a single entity without concern for internal details, controlling complexity by establishing new languages." },
"Procedural Abstraction": { "quote": "A technique for controlling complexity by hiding implementation details behind procedure boundaries." },
"Data Abstraction": { "quote": "The methodology of separating how data is used from how data is represented, distinguished by constructors and selectors." },
"Higher-Order Functions": { "quote": "Procedures that manipulate other procedures as arguments or return values, allowing powerful abstractions like map, filter, and reduce." },
"Recursion": { "quote": "The ability of a procedure to invoke itself, often the natural way to express solutions to problems that involve repetition." },
"Iterative Processes": { "quote": "Computational processes whose state can be summarized by a fixed number of state variables with simple update rules." },
"Recursive Processes": { "quote": "Computational processes characterized by a chain of deferred operations, often reflecting an underlying recursive problem structure." },
"First-Class Objects": { "quote": "Entities that can be named by variables, passed as arguments, returned as values, and included in data structures." },
"Metalinguistic Abstraction": { "quote": "Establishing new languages that are specialized for particular domains, thereby controlling complexity." },
"Environment Model": { "quote": "A model of computation where procedures are evaluated in environments that associate names with values." },
"Lexical Scoping": { "quote": "The convention where free variables in a procedure refer to bindings in the environment where the procedure was defined." },
"Closure": { "quote": "A procedure that carries its own environment, allowing it to access variables that were in scope when it was created." },
"State and Mutation": { "quote": "The introduction of assignment operations that change variable values, leading to the need for models of time in programming." },
"Streams": { "quote": "A powerful abstraction for dealing with sequential data, often implemented using delayed evaluation to handle infinite sequences." },
"Delayed Evaluation": { "quote": "Deferring evaluation of expressions until their values are needed, enabling flexible program organization." },
"Memoization": { "quote": "Saving previously computed values to avoid redundant computation, trading memory for time." },
"Symbolic Computing": { "quote": "Manipulation of symbols that represent mathematical expressions or other structured data." },
"Pattern Matching": { "quote": "Identifying and extracting components from structured data based on templates or patterns." },
"Generic Operations": { "quote": "Procedures that can operate on data of different types, implemented via type-directed dispatch." },
"Data-Directed Programming": { "quote": "An organizational strategy where operations are indexed by type, enabling modular extension of a system." },
"Message Passing": { "quote": "An organizational strategy where data objects respond to messages requesting operations." },
"Modularity": { "quote": "The design principle of composing large systems from well-defined, independent parts with clean interfaces." },
"Interpretation": { "quote": "The process of executing a program by modeling its evaluation directly instead of translating it to another form." },
"Compilation": { "quote": "The process of translating a program into a form that can be directly executed by a machine." },
"Register Machines": { "quote": "Abstract models of computers with explicit registers and operations, bridging high-level languages and hardware." },
"Explicit Control Evaluator": { "quote": "An interpreter that makes the control flow of evaluation explicit, moving toward machine implementations." },
"Lambda Calculus": { "quote": "A formal system for expressing computation based on function abstraction and application, underlying functional programming." },
"Normal Order Evaluation": { "quote": "A model of evaluation where operands are substituted unevaluated into the body of procedures, evaluating only when needed." },
"Applicative Order Evaluation": { "quote": "A model of evaluation where operands are evaluated before being passed to procedures, the standard in most languages." }
}
